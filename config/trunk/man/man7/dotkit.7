.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DOTKIT 1"
.TH DOTKIT 1 "2005-11-28" "Dotkit 1.0" "AX Local Docs"
.SH "NAME"
Dotkit \- A set of interchangeable parts for managing the Unix shell
environment.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This man page describes the overall organization of the Dotkit system.
Some other man pages are available for information
about specific parts of Dotkit:
See use(1) for basic instruction about Dotkit for the user.
See dk-commands(5) for a reference of each command, function,
or variable in the system.
See dk-examples(5) for worked-out examples of dotkits and related files,
and the rationale for their construction and location.
See the \s-1README\s0 file located in \f(CW$DK_ROOT\fR for a brief introduction,
initial installation, and \*(L"getting started\*(R" instructions.
For additional information about maintaining Dotkit,
see dk-admin(8).
.Sh "Some background on the problem"
.IX Subsection "Some background on the problem"
If you read many existing shell startup files,
you will observe that much of the conditional code \*(--
\&\*(L"if/else\*(R" or \*(L"case\*(R" and \*(L"switch\*(R" statements \*(--
uses the machine architecture or operating system type as its selector.
A small section from a (much longer) .cshrc file at our site reads:
.PP
.Vb 9
\&  if ($HostType == "Solaris") then
\&    set path = ( $path /usr/local/cvs/bin )
\&    set path = ( $path ~/bin/solaris )
\&  else if ($HostType == "Linux") then
\&    setenv PGI /usr/local/pgi
\&    set path = ( $path /usr/local/intel/compiler60/ia32/bin )
\&  else
\&    ...
\&  endif
.Ve
.PP
The process that set the value of \f(CW$HostType\fR above is not shown,
but it is quite useful to settle on a convention for
this process.
As a general statement,
the more widely the convention is understood and utilized,
the more useful it becomes.
Dotkit assumes such a convention, and uses an environment variable named
\&\s-1SYS_TYPE\s0 to express the value of the current system type.
.PP
Continuing the example from above,
a step in the direction of Dotkit is to divide your shell
startup file into several files,
one master, plus an additional file for each \s-1SYS_TYPE\s0.
Then the conditional code in the master file can
be reduced to one check:
.PP
.Vb 3
\&  if ( -e $HOME/.cshrc.$SYS_TYPE ) then
\&    source $HOME/.cshrc.$SYS_TYPE
\&  endif
.Ve
.PP
Each of the approaches to writing dotfiles shown above is workable.
(After all, we've been doing it this way for decades ....)
Some of the problems we have encountered might include:
.IP "\(bu" 2
\&\fIIf/else\fR and \fIcase\fR statements tend to get longer as time goes by.
They rarely get shorter,
even though some parts are no longer relevant.
.IP "\(bu" 2
The dotfiles require maintenance by (or on behalf of) each
user whenever a new \s-1SYS_TYPE\s0 appears, or other things change network\-wide;
.IP "\(bu" 2
In part because they are complicated,
dotfiles proliferate by sharing among users.
However, sharing code between users usually requires each recipient
to start a text editor and carry out a merge.
The historical variations between your and my dotfiles
may be trivial or they may not.
Even if they are trivial,
the code has to be read and understood (or not) over and over.
.IP "\(bu" 2
Sharing code across shell types (csh to bash, say) requires translation;
.IP "\(bu" 2
It is vexing to move a carefully tuned set of startup
files to a new environment.
\&\fIIf/else\fR constructions are brittle with respect to changes.
For example, in the case above, for HostType \*(L"Linux\*(R",
it doesn't matter that 
\&\s-1PGI\s0 was set prior to adding the intel compiler to \fIpath\fR.
However, that ordering is imposed by the code,
whether the code author intended it to matter or not.
.Sh "How Dotkit works"
.IX Subsection "How Dotkit works"
As mentioned already, one of the assumptions Dotkit starts with
is the notion of a received \s-1SYS_TYPE\s0 to guide basic decisions
about the environment.
The value of \s-1SYS_TYPE\s0 (\*(L"Solaris\*(R" or \*(L"Linux\*(R" in the above example)
might be set outside Dotkit as part of the standard login procedure,
or it can be set by Dotkit itself,
using a short script (provided) that applies some simple heuristic logic
to the output of \fIuname\fR\|(1).
Determining an appropriate value for \s-1SYS_TYPE\s0 on a given machine,
or deciding when two machines differ enough to merit different
values of \s-1SYS_TYPE\s0 can itself be a knotty problem,
but we'll assume that has been done in the further discussion.
.PP
Dotkit breaks out the shell code needed to set up a given
code system or other facility into a short package file or \fIdotkit\fR.
It is similar to the \fIModules\fR system (see references) in
this respect.
.PP
One difference from \fIModules\fR is that Dotkit
integrates site location, shell, and \s-1SYS_TYPE\s0 information
into the data structure of dotkits.
It then uses polymorphism or,
more simply, name overloading,
to select a particular piece of code (dotkit)
that satisfies the site, shell, \s-1USER\s0,
and \s-1SYS_TYPE\s0 requirements for that request.
The data structure (and the problem space, not incidentally)
is arranged such that the majority of package files
have only one instance.
E.g., if a given package does the same thing across multiple
shells and \s-1SYS_TYPE\s0's,
only one \*(-- shell and systype-independent \*(--
instance of the dotkit file needs to be written.
.Sh "How Dotkit finds package files"
.IX Subsection "How Dotkit finds package files"
Given a request such as \*(L"use foo\*(R",
Dotkit searches a list of directories for a file named \*(L"foo.dk\*(R",
taking the first such file found if there are multiple instances.
(The search algorithm is slightly modified for the special
case of \*(L"use Super\*(R".)
.PP
The list can be depicted as a two-level tree structure,
where each node in the upper level tree is itself the root of
a smaller tree of subnodes.  Every subtree has the same
structure as all others.
.PP
The first node searched in the upper tree is \fI$HOME/.kits\fR,
if it exists.
The last node searched is \f(CW$DK_ROOT\fR, which is guaranteed to exist.
In between, the entries in \f(CW$DK_NODE\fR, if they exist,
(two are shown in the diagram below) are the intermediate nodes:
.PP
.Vb 7
\&                           $DK_ROOT
\&                            /      \e
\&                           /        \e
\&                    $HOME/.kits  $DK_NODE[2]
\&                                    /
\&                                   /
\&                              $DK_NODE[1]
.Ve
.PP
.Vb 1
\&                Tree of Nodes Searched by Dotkit
.Ve
.PP
As previously stated, each node in the tree above
is the root of a subtree, laid out as shown below:
.PP
.Vb 7
\&                            (.)
\&                            / \e
\&                           /   \e
\&                        *sh   $SYS_TYPE
\&                          \e
\&                           \e
\&                          $SYS_TYPE
.Ve
.PP
.Vb 1
\&                 Directory layout of One Node
.Ve
.PP
That is, the node directory itself, signified by (.), has
sub-directories corresponding to each of the supported shell
types \- bash, csh, ksh, and tcsh \-
and it has sub-directories corresponding to each possible \s-1SYS_TYPE\s0
in the network at hand.
Each \fI*sh\fR sub-directory may itself have \s-1SYS_TYPE\s0 sub\-directories.
Empty nodes and sub-directories do not need to be created or searched.
.PP
Dotkit traverses the logical tree under \f(CW$DK_ROOT\fR left to right,
in post\-order:
Visit the children, then visit the node itself.
This means that the \fI$HOME/.kits\fR node is visited first,
and will always win the race to find
a given package file.
The post-order traverse continues in the subnodes,
so that within \fI$HOME/.kits\fR, the \fI*sh/$SYS_TYPE\fR directory
is visited first,
and \fI$HOME/.kits/.\fR (the node directory itself) is visited last.
.PP
Three characteristics of the Dotkit search process might
be highlighted here:
.IP "\(bu" 2
It dynamically adapts to the \s-1USER\s0, shell, system type,
and site.
.IP "\(bu" 2
As discussed further below,
it defines an ordering that can be utilized to inherit general
characteristics into more-specific dotkits.
.IP "\(bu" 2
The tree is under user control,
and can be dynamically modified to suit project purposes.
.Sh "The scope of a dotkit"
.IX Subsection "The scope of a dotkit"
In practice, the \fI*sh\fR sub-directories are usually empty,
except in \f(CW$DK_ROOT\fR itself.
(Dotkit is implemented as a set of shell scripts,
so what better place to store each shell's code 
than \fI$DK_ROOT/*sh\fR?)
.PP
In a logical sense, the dotkits stored in the \f(CW$DK_ROOT\fR
node describe software systems that are universal,
available everywhere,
independent of site or user or system type.
For example, the package \*(L"bin.dk\*(R" is stored at \f(CW$DK_ROOT\fR/.
It simply adds /bin to \s-1PATH\s0.
This action is useful on any Unix or Unix-like system.
.PP
The \fI$DK_ROOT/$SYS_TYPE\fR directory stores dotkits that should
apply to every system of type \f(CW$SYS_TYPE\fR,
wherever they are.
For example, the dotkit \fI$DK_ROOT/redhat_9_ia32/x11.dk\fR
adds /usr/X11R6/bin to \s-1PATH\s0, and /usr/X11R6/man to \s-1MANPATH\s0
on every system running Redhat Linux, version 9.
There is also a \fI$DK_ROOT/x11.dk\fR file,
which adds /usr/bin/X11 to \s-1PATH\s0.
The first variant is the one found if your current \f(CW$SYS_TYPE\fR
happens to match \*(L"redhat_9_ia32\*(R";
otherwise, the second is used.
.PP
The \fI$HOME/.kits/\fR node stores your personal dotkits.
You can create your own set of new dotkits as needed,
categorizing them according to \s-1SYS_TYPE\s0 or \fI*sh\fR if necessary,
or you can over-ride system dotkits by reusing their file name,
and creating your own new actions.
No one but you has direct access to your personal dotkits.
However, if you want to share,
you can place your unmodified dotkit in a node that is visible
to other Dotkit users,
or they can copy your file, unchanged,
to their own personal stash of kits.
.PP
The nodes listed in \f(CW$DK_NODE\fR, if any,
are usually used for site-specific or project-specific dotkits.
(A \*(L"site\*(R" is typically that portion of a network
under a single administrative domain.
Or it may simply be the set of machines that have common \s-1NFS\s0 access
to \f(CW$DK_ROOT\fR.)
These node(s) are searched after your personal node,
but before the universal node.
.Sh "More about site nodes"
.IX Subsection "More about site nodes"
By convention, a site node is a directory whose name begins
with the string \*(L"site=\*(R".
It has the internal structure shown in the second diagram above,
and it can be located anywhere in the file system.
It is often convenient, but not required,
to locate site nodes as physical subdirectories of \f(CW$DK_ROOT\fR.
.PP
A site node identifies a set of dotkits that belong to
and describe the software available at that site.
For example, \fIsite=olbullit\fR identifies dotkits for my personal machine,
which I manage as a stand-alone host.
On that machine, my \s-1DK_NODE\s0 setting is simple:
.PP
.Vb 1
\&  DK_NODE=$DK_ROOT/site=olbullit
.Ve
.PP
Like olbullit,
many or most sites need have only a single entry in \s-1DK_NODE\s0.
.PP
As a more demanding example,
in my working environment,
I have accounts at two primary sites.
One is a division-wide network (\s-1OAX\s0),
and the other is a Lab-wide network (\s-1OCF\s0).
They are managed separately,
and have separate \f(CW$DK_ROOT\fR directories.
Each has some software that is unique,
and some that is the same as the other network.
It has therefore been useful to divide their dotkits into
three sets:
One for \s-1OAX\s0 alone, one for \s-1OCF\s0 alone,
and one for dotkits that are the same at both sites.
Consider the proper setting for \fI\s-1DK_NODE\s0\fR on my local \s-1OAX\s0 network:
.PP
.Vb 1
\&  DK_NODE=$DK_ROOT/site=oax:$DK_ROOT/site=oax+ocf
.Ve
.PP
In words, this says that for any site-specific dotkit,
we look first in the \s-1OAX\s0 node.
(We're on the \s-1OAX\s0 network, so it takes precedence.)
If there is no match, look next in the \s-1OAX+OCF\s0 node,
where dotkits that work for either network can be found.
.PP
On the \s-1OCF\s0 network, the setting for \s-1DK_NODE\s0 becomes:
.PP
.Vb 1
\&  DK_NODE=$DK_ROOT/site=ocf:$DK_ROOT/site=oax+ocf
.Ve
.PP
\&\fISite=ocf\fR takes the place of \fIsite=oax\fR.
\&\s-1DK_NODE\s0 makes it easy to customize Dotkit to a site
with minimal configuration effort.
.PP
Adding site nodes to \s-1DK_NODE\s0 is a task usually assigned to
the Dotkit maintainer at that site.
In addition to site nodes,
individual users can add entries to \s-1DK_NODE\s0 that make project-specific
or other collections of dotkits available to the project contributors.
.PP
If your network is large,
it is also possible to divide up the contents of a site node
into \fIsubsites\fR,
each containing a useful category of software available at
your site,
such as compilers,
parallel libraries, and so on.
.PP
A subsite is structured exactly like a site,
conventionally named \fIsubsite=FOO\fR.
One dotkit in the primary site node is associated with
each subsite,
and modifies \fI\s-1DK_NODE\s0\fR to add (\fIuse\fR) or remove (\fIunuse\fR) the subsite.
.Sh "Customizing the search within nodes"
.IX Subsection "Customizing the search within nodes"
\&\s-1DK_NODE\s0 gives you and your site maintainers the ability
to define the nodes on the Dotkit search tree (the first
diagram shown above.)
If you or your site has special requirements,
it is also possible to modify the tree internal to each node,
by changing the value of the environment
variable \f(CW$DK_SUBNODE\fR, set in \fI$DK_ROOT/$_dk_shell/.dk_init\fR.
.PP
For example, if your network is organized as many small client
workstations around a couple of large application servers,
it might make sense to use the \f(CW$HOSTNAME\fR instead of or in
addition to \f(CW$SYS_TYPE\fR as a selector inside each node.
In this way, the view of available applications (dotkits) would
vary according to whether you were logged into a client
or an application server.
.Sh "Small Dotkit installations"
.IX Subsection "Small Dotkit installations"
The discussion above describes how to configure Dotkit for a
large multi-network situation.
Dotkit is also well-suited to a small network or a single machine.
It is distributed as a single small tar file.
Installation consists of choosing a location for \s-1DK_ROOT\s0,
which may well be your \s-1HOME\s0 directory,
and unpacking the tar file at that spot.
At this point, Dotkit is fully usable without having to compile
any code or create any dotkits of your own.
The universal dotkits under \f(CW$DK_ROOT\fR
are all available with no setup.
Further customization for yourself or your site can then be done as needed.
.Sh "Use\-usage, and other miscellany"
.IX Subsection "Use-usage, and other miscellany"
When you type \*(L"use\*(R" with no arguments,
or with just the \fB\-a\fR or \fB\-v\fR options,
or \*(L"use \-l\*(R" with or without file arguments,
Dotkit arranges to run
a shell script named \*(L"use\-usage\*(R", located at
\&\fI$DK_ROOT/etc\fR.
This script looks for a file named \fI$DK_ROOT/etc/DK_MAINTAINER\fR,
whose contents is the name of the person who will maintain
Dotkit for your site.
Another optional file named \*(L"dk\-news\*(R" can also be placed at \fI$DK_ROOT/etc\fR,
to provide site-wide notice of updates, additions, or other changes
to Dotkit at your location.
.PP
If you prefer, you can write your own usage program,
by defining \fI\s-1DK_USEUSAGE\s0\fR to the pathname of an executable
program or script.
.PP
Also at \fI$DK_ROOT/etc/\fR find a script named \*(L"envdiff\*(R", a helper
program used by the \*(L"envdiff\*(R" dotkit,
a makefile for various maintenance operations,
the \*(L"systype\*(R" script used to compute values of \f(CW$SYS_TYPE\fR,
a \fItest/\fR subdirectory with several Dotkit regression tests,
and the \*(L"where\*(R", \*(L"alias\*(R", and \*(L"rep\*(R" scripts referenced by the \fIdk_where\fR,
\&\fIdk_alias\fR, and \fIdk_rep\fR commands.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
(Dotkit environment variables are documented in \fIdk\-commands\fR\|(5).)
.SH "AUTHOR"
.IX Header "AUTHOR"
The original author of Dotkit is
Lee Busby, Lawrence Livermore National Laboratory.
Adam Moody, also of \s-1LLNL\s0,
has made additional major contributions.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004, The Regents of the University of California.
See the file named \*(L"Copyright\*(R" for the full text of the copyright notice.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
dk-commands(5), dk-examples(5), dotkit(7), use(1), dk-admin(8).
.PP
\&\*(L"Modules: Providing a Flexible User Environment\*(R",
John L. Furlani, proceedings of Large Installation
Systems Administration V (\s-1LISA\s0 V), \s-1USENIX\s0 Association,
October, 1991.
.PP
\&\*(L"user\-setup: A System for Custom Configuration of User Environments ...\*(R",
Richard Elling and Matthew Long,
proceedings of \s-1LISA\s0 \s-1VI\s0, \s-1USENIX\s0 Association,
October, 1992.
.PP
The \s-1ENVV\s0 package, contributed by David F. Skoll,
comp.sources.misc, Volume 42, Issue 70,
May, 1994.
.PP
\&\*(L"Soft: A Software Environment Abstraction Mechanism\*(R",
Remy Evard and Robert Leslie,
proceedings of \s-1LISA\s0 \s-1VIII\s0, \s-1USENIX\s0 Association,
September, 1994.
.PP
\&\*(L"Abstract Yourself With Modules\*(R",
J.L. Furlani, Peter W. Osel,
proceedings of \s-1LISA\s0 X, \s-1USENIX\s0 Association,
October, 1996.
.PP
\&\*(L"Global Impact Analysis of Dynamic Library Dependencies\*(R",
Yizhan Sun, Alva L. Couch,
proceedings of \s-1LISA\s0 \s-1XV\s0, \s-1USENIX\s0 Association,
December, 2001.
(Introduced the author to \fIuse\fR, \fIunuse\fR as package access commands.)
