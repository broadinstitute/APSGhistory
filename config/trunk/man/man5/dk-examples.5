.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DK-EXAMPLES 1"
.TH DK-EXAMPLES 1 "2005-11-28" "Dotkit 1.0" "AX Local Docs"
.SH "NAME"
Dotkit by example \- Examples and rationale for writing your own dotkits.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This man page provides examples of some dotkits,
and discusses the rationale for their construction and
placement in the system.
See \fIuse\fR\|(1) for a general introduction to using Dotkit.
See \fIdk\-commands\fR\|(5) for reference documentation on all
the Dotkit commands, functions and variables.
See \fIdotkit\fR\|(7) for discussion of the motivation behind Dotkit,
its overall organization and structure,
and strategies for fitting it to a given situation.
.Sh "How to write a dotkit"
.IX Subsection "How to write a dotkit"
.RS 6
A dotkit is a file named \fIsomething\fR.dk,
containing instructions to modify your environment so as to
match the requirements of a given software system.
.Sp
Most dotkits are very simple.
The first line of the file categorizes the kit into one of several kinds.
This is followed by a one-line textual description of the kit's purpose,
possibly followed with some additional help.
After that, you modify environment variables as needed
to do the job.  Here is \f(CW$DK_ROOT\fR/bin.dk (a four-line file):
.Sp
.Vb 2
\&  #c shell
\&  #d Add /bin to PATH
.Ve
.Sp
.Vb 1
\&  dk_alter PATH /bin
.Ve
.Sp
The ``#c'' at the beginning of the first line tells Dotkit that this
package is part of the \*(L"shell\*(R" category.
(Most of the dotkits that ship with the system are in this category.)
The line \*(L"Add /bin to \s-1PATH\s0\*(R", beginning with ``#d'',
is descriptive text.
Descriptive text lines (there can be more than one) should generally be kept
to 65 characters or less
for neat display by \fIuse-usage\fR.
.Sp
The \fIdk_alter\fR line accomplishes two things:
If you are using the kit, it adds \*(L"/bin\*(R" to your \s-1PATH\s0,
while if you are unusing the kit, it deletes \*(L"/bin\*(R" from
your \s-1PATH\s0.
The end user controls whether \*(L"/bin\*(R" goes at the beginning or
end of their \s-1PATH\s0,
with the \fB\-a\fR option for \fIuse\fR.
.Sp
The category/sub\-category and descriptive text at the beginning of
each dotkit file allows
you to publish the existence and purpose of your package to all
the users of Dotkit.
They are collated together by the \fIuse-usage\fR program
when you run \*(L"use \-l\*(R" to
display all the available dotkits in a nicely formatted list.
Otherwise, they don't affect the operation of Dotkit in any way.
(\fIUse-usage\fR is the program that runs when you type \*(L"use\*(R" with no arguments,
or \*(L"use \-l\*(R".)
.Sp
Besides \fIdk_alter\fR,
the other command used most frequently inside a dotkit
is \fIdk_setenv\fR.
It is common for applications to look for auxiliary
environment variables specific to them.
Here is the \*(L"less.dk\*(R" dotkit:
.Sp
.Vb 2
\&  #c shell
\&  #d Set up PAGER as "less" if available, or fall back to "more"
.Ve
.Sp
.Vb 5
\&  dk_setenv PAGER `dk_where less` || \e
\&    dk_setenv PAGER `dk_where more`
\&  dk_setenv LESS -isceM
\&  dk_setenv MANPAGER $PAGER
\&  dk_setenv MORE -c
.Ve
.Sp
This package does several things.
The first \fIdk_setenv\fR line uses \fIdk_where\fR to look
for the pathname of the \*(L"less\*(R" pager.
If that cannot be found,
we settle for setting \s-1PAGER\s0 to the pathname of \*(L"more\*(R",
which is presumed to be available everywhere.
.Sp
The last 3 lines set options for both less and more,
and make sure that the \*(L"man\*(R" utility uses the same \s-1PAGER\s0
as everything else.
.RE
.Sh "Fancier, but still simple, dotkits"
.IX Subsection "Fancier, but still simple, dotkits"
.RS 6
Quoting of variables inside a dotkit is not usually required,
unless the value of the variable contains white space.
Simple applications of \fIeval\fR (hopefully) behave as you would expect:
.Sp
.Vb 4
\&  dk_setenv A AAA
\&  dk_setenv A2 "X Y Z"
\&  dk_setenv C B
\&  eval dk_setenv $C $A
.Ve
.Sp
In addition to \fIA\fR, \fIA2\fR, and \fIC\fR,
the last \fIdk_setenv\fR will
create an environment variable \fIB\fR with value \fI\s-1AAA\s0\fR.
.Sp
As you have already seen,
conditional code can be put into dotkits using the standard
``And/Or'' command list syntax common to all Unix shells:
.Sp
.Vb 3
\&  grep foobar /etc/passwd >/dev/null && \e
\&    dk_setenv X A || \e
\&    dk_setenv X B
.Ve
.Sp
will set the environment variable \fIX\fR to 'A' if the name 'foobar'
appears in /etc/passwd, or to 'B' otherwise.
.Sp
\&\fIDk_source\fR allows you to read the contents of another file
from within a dotkit.
This is sometimes useful,
especially to utilize pre-existing or external code
that sets up the environment for some application.
.Sp
Unless you know \fIa priori\fR that the dk_source'd file is written
in shell-independent fashion,
you might need to test the current shell
in order to choose the appropriate file to source:
.Sp
.Vb 3
\&  dk_test $_dk_shell = csh -o $_dk_shell = tcsh && \e
\&    dk_source foo.csh || \e
\&    dk_source foo.sh
.Ve
.Sp
\&\fI_Dk_shell\fR is an internal variable available inside
any dotkit, containing the (base) name of your shell.
.RE
.Sh "Reusable or idempotent dotkits"
.IX Subsection "Reusable or idempotent dotkits"
.RS 6
Any dotkit can be reused, if you just \fIunuse\fR it first.
There is even a \fIreuse\fR command to do that.
Normally, however, Dotkit will decline to read the text of a
package file more than once,
telling you that the dotkit was \*(L"already loaded\*(R".
An \fIidempotent\fR dotkit allows you to break that rule,
by giving the kit a base name that ends with the 2 characters '++'.
(The file name extension is still \fI.dk\fR.)
In this case, Dotkit
will re-read the file even if it has previously been seen.
This is usually of interest only in the case where a
dotkit contains \fIdk_alias\fR definitions.
.Sp
Shell aliases are not inherited by subshells,
and are treated differently from environment variables
at login time,
or when a subshell is started.
You therefore probably want to place your \fIdk_alias\fR definitions
in a \fIreusable\fR dotkit.
.Sp
Alternatively, you can set up Dotkit so that it always re-reads
every package, even if the package has previously been loaded.
Set the environment variable \fI\s-1DK_UEQRU\s0\fR to 1 (there is
a special \*(L"reuse\*(R" package available that does this for you).
Then every \*(L"use\*(R" behaves as if you had typed \*(L"reuse\*(R".
Although it slows things down a little,
this can be good if Dotkit is not the only process that
might be making changes to your environment.
.RE
.Sh "Recursive or nested dotkits"
.IX Subsection "Recursive or nested dotkits"
.RS 6
Dotkits can include other dotkits,
up to 9 levels deep.
This allows you to compose and name a set of modifications
to the environment by combining the effects of one or
more other dotkits.
.Sp
Suppose you want to write a recursive dotkit that includes
several others.
You might start off by creating the file \*(L"Fancy.dk\*(R", with
contents as follows:
.Sp
.Vb 2
\&  #c personal
\&  #d My fancy package, includes bin, etc, local, sbin packages
.Ve
.Sp
.Vb 1
\&  use -q bin etc local sbin
.Ve
.Sp
This is almost correct.
When you type \*(L"use Fancy\*(R",
the effect is to load it (which otherwise does nothing),
then the four other named packages.
The only problem comes when you want to \*(L"unuse Fancy\*(R".
It would be nice if that line beginning \*(L"use \-q ...\*(R"
would somehow magically turn into \*(L"unuse \-q ...\*(R"
This is what \fIdk_op\fR does.
Write the line instead as
.Sp
.Vb 1
\&  dk_op -q bin etc local sbin
.Ve
.Sp
and it means \*(L"use\*(R" or \*(L"unuse\*(R" (quietly) those four packages,
depending on whether you are using or unusing the \*(L"Fancy\*(R" package.
.Sp
As a general rule,
a dotkit can't include itself (but see \fISuper\fR below.)
It can, however, \fIunuse\fR itself,
as the following section makes clear.
.RE
.Sh "Mutually exclusive (mutex) dotkits"
.IX Subsection "Mutually exclusive (mutex) dotkits"
.RS 6
Recursion offers a nice solution to another common problem
in managing your environment.
Many commands, libraries,
or code systems are installed in multiple versions.
Suppose you have three versions of gcc installed, version 1.1, 1.2,
and 1.3,
with 3 dotkits named gcc\-1.1, gcc\-1.2, gcc\-1.3, respectively.
In order to set your environment for using 1.1,
you would type \*(L"use gcc\-1.1\*(R",
and so forth.
Here is what the package file for gcc\-1.1
might look like:
.Sp
.Vb 2
\&  #c compilers/gnu
\&  #d GCC version 1.1
.Ve
.Sp
.Vb 1
\&  unuse -q gcc-1.1 gcc-1.2 gcc-1.3
.Ve
.Sp
.Vb 2
\&  dk_setenv COMPILER gcc_1_1
\&  dk_alter PATH /usr/local/gcc-1.1/bin
.Ve
.Sp
The initial \fIunuse\fR command clears all variants of this package (if any)
from your
environment before the dk_setenv and dk_alter commands add back the
changes for this specific package.
Note that the \fIunuse\fR mentions \*(L"gcc\-1.1\*(R",
which is the name of this particular package itself.
Dotkit notices,
and ignores,
a trivial self-reference in this (unuse) case.
This allows you to put an identical \*(L"unuse\*(R" line in all
variants of a package.
See \fISuper dotkits\fR below for more about self-reference in
the \fIuse\fR case.
.Sp
The pattern \*(L"unuse \-q <all variants>\*(R" is so common that Dotkit
includes special support for it with the \fIdk_rep\fR command.
Although the example as given above works fine,
it requires old packages to change every time a new variant
is added.  It would be nicer to be able to refer to all the
variants of a given mutex family by using a pattern for their names.
Thus, a better way to write the \*(L"unuse\*(R" line for the given example
is like this:
.Sp
.Vb 1
\&  unuse -q `dk_rep 'gcc-*'`
.Ve
.Sp
The \fIdk_rep\fR command is reminiscent of Perl's \fIgrep\fR command,
operating on Dotkit's built-in list of packages in
current use.  In this case, it finds any package already loaded
whose name matches \*(L"gcc\-*\*(R".
.RE
.Sh "Super dotkits"
.IX Subsection "Super dotkits"
.RS 6
One more variation on recursion is the so-called \*(L"Super\*(R" package.
(It may be useful to now read the
section \fIHow Dotkit finds package files\fR,
in the \fIdotkit\fR\|(1) man page.)
Briefly, kits are arranged in a hierarchy from the most general
or universally applicable (those under \f(CW$DK_ROOT\fR itself),
to the most specific
(your personal dotkits, under \f(CW$HOME\fR/.kits/),
with site-wide or project dotkits intermediate between
those extremes.
.Sp
You can write universal, site, \s-1SYS_TYPE\s0, shell\-specific, or personal
versions of any given package by choosing its location in the
hierarchy.
You override the more general version of a dotkit by creating
a new package with the same name,
and placing it in a more specific location.
Moreover, you can choose whether to override the general version entirely,
or you can \*(L"inherit\*(R" the general version(s) by the
artifice of the \*(L"Super\*(R" package.
.Sp
Refer back to the \*(L"less.dk\*(R" example shown earlier.
Suppose you like everything about that package,
but would prefer to change the \s-1MORE\s0 option from \fB\-c\fR
to \fB\-p\fR.
Create a personal dotkit named \*(L"less.dk\*(R",
(the same name as the universal kit),
located at \f(CW$HOME\fR/.kits (your personal node in the Dotkit search path.)
Your version first loads the universal package,
then makes the adjustment you desire:
.Sp
.Vb 2
\&  #c personal
\&  #d My personal less/more options
.Ve
.Sp
.Vb 2
\&  dk_op -q Super
\&  dk_setenv MORE -p
.Ve
.Sp
\&\fISuper\fR is a self\-reference,
interpreted by Dotkit to mean the \*(L"next package up\*(R" by the same name
in the hierarchy.
It allows you to construct a dotkit by
selecting general capabilities,
then making more and more specific additions or changes.
.Sp
Use of \fISuper\fR can be chained, if there are more than 2 versions
of a given package in the Dotkit search tree.
Each use of \fISuper\fR finds the next upward instance of the current dotkit.
.Sp
Self-reference in any other context will generally cause a \*(L"Recursion
limit exceeded!\*(R" error.
This usually happens when two (different) packages reference each other.
.RE
.Sh "Sub-site access dotkits"
.IX Subsection "Sub-site access dotkits"
.RS 6
A large network may serve several audiences,
not all of whom want to see the entire array of dotkits
that are otherwise available at the site.
.Sp
For example,
your site may have 12 varieties of \s-1MPI\s0 libraries,
with 12 different dotkits to select from.
The only users who probably want to see those 12 dotkits
are developers who compile parallel \s-1MPI\s0 programs.
.Sp
The sub-site dotkit for this example might be a file named \fImpi.dk\fR,
located in the site node, with contents such as
.Sp
.Vb 2
\&  #c sub-site
\&  #d Add MPI library selections to your catalog.
.Ve
.Sp
.Vb 1
\&  dk_alter DK_NODE /foo/bar/subsite=mpi
.Ve
.Sp
Every user will see the \fImpi\fR dotkit in their catalog,
while those who \fIuse mpi\fR will thenceforth have all the
mpi-related dotkits added to their catalog listing.
.Sp
This mechanism allows the user to control the size and contents
of their dotkit catalog.
It also allows delegation of responsibility for maintaining
dotkits to a group of people,
each assigned to one sub\-site.
.RE
.Sh "SYS_TYPE\-specific dotkits"
.IX Subsection "SYS_TYPE-specific dotkits"
.RS 6
Sometimes, programs are available on just one kind of machine on your network,
or their location varies depending on the host type.
Dotkit provides for this common situation,
in the form of a \f(CW$SYS_TYPE\fR sub-directory of each node in the
Dotkit search path.
The package files themselves look exactly the same as described above,
but their location in the search path makes them visible
only on the set of hosts where that is useful.
.Sp
For example, there is a universal \fIx11\fR dotkit with contents:
.Sp
.Vb 2
\&  #c shell
\&  #d generic X11 commands (/usr/bin/X11)
.Ve
.Sp
.Vb 1
\&  dk_alter PATH /usr/bin/X11
.Ve
.Sp
On our networks, the machines that run Redhat Linux have a \s-1SYS_TYPE\s0
value of \fIredhat_9_ia32\fR.
There is also an \fIx11\fR dotkit for them,
located at \fI$DK_ROOT/redhat_9_ia32\fR:
.Sp
.Vb 2
\&  #c shell
\&  #d Add /usr/X11R6/{bin,man} to PATH, MANPATH
.Ve
.Sp
.Vb 2
\&  dk_alter PATH /usr/X11R6/bin
\&  dk_alter MANPATH  /usr/X11R6/man
.Ve
.Sp
Whenever you log into a Linux host and \*(L"use x11\*(R",
Dotkit finds the second, SYS_TYPE\-specific version.
Otherwise, it finds the generic kit.
.Sp
\&\s-1SYS_TYPE\s0 works well for many cases where you need to make
host type distinctions.
Sometimes it is too fine\-grained.
For example, the \s-1SYS_TYPE\s0 value for the same Linux machines
used to be \fIredhat_7_ia32\fR,
before our last operating system upgrade.
If two \s-1SYS_TYPE\s0 values really do share essentially all the
same dotkits,
it is sufficient to make the new \s-1SYS_TYPE\s0 value a symbolic
link to the old value.
Otherwise, it may take a new \s-1SYS_TYPE\s0 directory,
and some duplication or linking of individual dotkits between
the new and old.
.Sp
Another situation might occur where only one host of a given
\&\s-1SYS_TYPE\s0 has a particular package.
(This is frequently due to licensing restrictions.)
In that case, you may choose to write a SYS_TYPE\-specific
package something like this:
.Sp
.Vb 2
\&  #c special
\&  #d The hotstuff application
.Ve
.Sp
.Vb 2
\&  dk_test `hostname` = "frodo" || \e
\&    setenv _dk_err "Sorry, only frodo can run hotstuff"
.Ve
.Sp
.Vb 2
\&  dk_setenv HOTSTUFF /opt/hotstuff
\&  dk_alter PATH $HOTSTUFF/bin
.Ve
.Sp
Then, if an attempt to \*(L"use hotstuff\*(R" on any machine other than
frodo occurs, a polite message is printed declining the request.
.RE
.Sh "Shell-specific dotkits"
.IX Subsection "Shell-specific dotkits"
.RS 6
If the commands and techniques above are inadequate to carry
out a needed computation inside a package file,
you have the option of writing to the ``bare metal'' of any given shell.
Such a package is normally located in a \fI*sh\fR sub-directory of
one of the nodes on the Dotkit search path (see \fIdotkit\fR\|(7) for a full
discussion of the search process.)
And if you desire to make the functionality available to users
of other shell types,
you will need to write shell-specific versions of the package
for those shells, too.
.Sp
The first line of a shell-specific package is a
comment structured as shown previously.
After that, you can write pure
\&\fIbash\fR, \fIcsh\fR, \fIksh\fR, or \fItcsh\fR
code as necessary to get the job done.
Any of the commands documented in \fIdk\-commands\fR\|(5) can be used if you wish.
.Sp
A common approach in a shell-specific package is to 
write it in two sections, one for \*(L"use\*(R" and another for \*(L"unuse\*(R".
The \fI_dk_op\fR variable (note the leading underscore)
is available for this purpose.
A short but complete shell-specific package (for tcsh) is as follows:
.Sp
.Vb 2
\&  #c shell/dotkit
\&  #d Set/unset the rmstar variable
.Ve
.Sp
.Vb 5
\&  if( $_dk_op == "use" ) then
\&    set rmstar
\&  else # unuse
\&    unset rmstar
\&  endif
.Ve
.Sp
\&\fIRmstar\fR is a shell variable known only in \fItcsh\fR,
that, if set, prompts the user before executing an "rm\ *" command.
Since it's only available to users of that shell,
the code to set or unset it should be in a shell-specific
package.
.RE
.Sh "How to hide a dotkit"
.IX Subsection "How to hide a dotkit"
.RS 6
Not every dotkit necessarily has to be catalogued.
Some may do work on behalf of other kits.
Some may be for testing.
Whatever.
If the name of a dotkit begins with \*(L".\*(R",
it won't show up in the output from \fIuse-usage\fR
unless the \fB\-a\fR option is also given.
However, the kit will still be found and loaded if
you \*(L"use\*(R" it by its proper name.
.Sp
If the first line of the kit is not a shell comment
(beginning with '#'),
the kit won't show up in \fIuse-usage\fR either,
regardless of its name or the options given.
Like the first case, it will still be found and loaded
if named explicitly.
.Sp
If the internals of the kit include the line
.Sp
.Vb 1
\&  setenv _dk_hide 1,
.Ve
.Sp
the kit will show up normally in \fIuse-usage\fR,
and will be found and loaded if named explicitly,
but will not then be listed in the set of kits currently in use.
This allows you to subsequently read the kit again
without unusing it first.
.RE
.Sh "Dotfile setup"
.IX Subsection "Dotfile setup"
.RS 6
If you have read this far, perhaps you are considering whether
Dotkit would be useful to incorporate into your own shell
startup files.
It was after all designed to help make those files shorter,
easier to read, and more independent of system considerations.
.Sp
There is a small but complete working set of example shell startup files
located at \fI$DK_ROOT/etc/example/\fR,
along with a personal \fI$HOME/.kits/\fR directory
for any of the four shells currently covered by Dotkit.
Let's look at the \*(L"cshrc\*(R" startup file to consider a few of your options:
.Sp
.Vb 1
\&  # A basic .cshrc for use with Dotkit for csh and tcsh.
.Ve
.Sp
.Vb 9
\&  #setenv DK_NODE /my/special/dotkits # optional project or group dotkits
\&  # Look for Dotkit first in $DK_ROOT, then $HOME, then LLNL default.
\&  if ( $?DK_ROOT ) then
\&    eval `$DK_ROOT/init -c`
\&  else if ( -d "$HOME/dotkit" ) then
\&    eval `$HOME/dotkit/init -c`
\&  else if ( -d "/usr/gapps/dotkit" ) then
\&    eval `/usr/gapps/dotkit/init -c`
\&  endif
.Ve
.Sp
.Vb 5
\&  # This conditional needs to execute once only.
\&  if ( ! $?SETUP_ONCE ) then
\&    setenv SETUP_ONCE 1
\&    use -q Sys Dev Prefs
\&  endif
.Ve
.Sp
.Vb 2
\&  # Remainder is read by every shell instance.
\&  use -q alia1++ myalia++
.Ve
.Sp
As you probably know already, a \fIcsh\fR process reads one or more files
when it starts: \fI/etc/cshrc\fR, \fI$HOME/.cshrc\fR, and if it is a \*(L"login\*(R"
shell, \fI$HOME/.login\fR.
There is a lot of variation in the exact name of the first file listed.
Tcsh supplies many other alternative files,
and can be compiled with further variant options.
I won't consider those here.
.Sp
Csh was designed so that login shells would read both of \fI$HOME/.cshrc\fR
and \fI$HOME/.login\fR, in that order,
while all other shell instances would read only \fI$HOME/.cshrc\fR.
In particular,
remote shells started by \fIrsh\fR or \fIssh\fR typically are not login shells,
nor are those shell instances started by an X window display manager.
Many users have therefore found \fI$HOME/.login\fR to be of minimal value.
The example above assumes that there is no \fI$HOME/.login\fR
file at all.  It does all the work traditionally done by the pair,
with a conditional check to prevent most redundant setup.
With that in mind, look at the first of the three sections in the file.
.Sp
The \fIsetenv \s-1DK_NODE\s0\fR line is optional, if you should need to
reference dotkits in locations other than \fI$DK_ROOT\fR or
site-specific locations set up by the Dotkit maintainer.
If you do set it, do so before the \fIeval\fR line,
because the \fIinit\fR script may append site-specific components
to \s-1DK_NODE\s0.
.Sp
The seven line if/else test to locate a copy of Dotkit shows one approach
that can be used to initialize the system.
It can be reduced to a single \fIeval\fR if you really only
need to reference one copy of Dotkit.
.Sp
Section two is the \fIif\fR test on \s-1SETUP_ONCE\s0.
This piece of code could reasonably be moved to \f(CW$HOME\fR/.login,
if you prefer that arrangement,
because it sets up environment variables that normally will
be inherited automatically by any subsequent subshells.
You could also choose to replace the "use\ \-q\ ..." statement
with a simpler (faster) group of statements that set up
a more minimal initial environment.
.Sp
Dotkit enables a new way to view your environment.
Previously, most of us have built startup dotfiles that throw in
all possible contingencies,
because it is painful to change the environment later.
With Dotkit,
you can start from a minimal environment,
and add to or change it later on.
.Sp
Section three is the \*(L"Remainder\*(R".
It defines aliases,
and so needs to be read by most shells.
You might surround this line with an \fIif($?prompt)\fR test
to keep non-interactive shells from looking for alia.
Or you might choose to just set up your own alia definitions
directly in this file,
if your desires are simple.
If you do choose to \fIuse\fR,
note that the dotkits need to be idempotent,
or the request to re-read them will be ignored.
.RE
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
(See \fIdk\-commands\fR\|(5) for the Dotkit environment variables.)
.SH "AUTHOR"
.IX Header "AUTHOR"
The original author of Dotkit is
Lee Busby, Lawrence Livermore National Laboratory.
Adam Moody, also of \s-1LLNL\s0,
has made additional major contributions.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004, The Regents of the University of California.
See the file named \*(L"Copyright\*(R" for the full text of the copyright notice.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
dk-commands(5), dk-examples(5), dotkit(7), use(1), dk-admin(8).
