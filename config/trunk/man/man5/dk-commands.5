.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DK-COMMANDS 1"
.TH DK-COMMANDS 1 "2005-11-28" "Dotkit 1.0" "AX Local Docs"
.SH "NAME"
The reference document for all Dotkit commands, functions and special variables.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Sh "Dotkit commands for interactive or shell script use"
.IX Subsection "Dotkit commands for interactive or shell script use"
use [ \fB\-alqv\fR ] [ \fIpkg\fR ... ]
.PP
unuse [ \fB\-alqv\fR ] [ \fIpkg\fR ... ]
.PP
reuse [ \fB\-alqv\fR ] [ \fIpkg\fR ... ]
.PP
alter [ \fB\-a\fR ] \fI\s-1VARIABLE\s0\fR \fI\s-1COMPONENT\s0\fR [ \fI\s-1SEPARATOR\s0\fR ]
.PP
unalter \fI\s-1VARIABLE\s0\fR \fI\s-1COMPONENT\s0\fR [ \fI\s-1SEPARATOR\s0\fR ]
.PP
car \fI\s-1WORDLIST_VALUE\s0\fR [ \fI\s-1NTH\s0\fR ] [ \fI\s-1SEPARATOR\s0\fR ]
.PP
cdr \fI\s-1WORDLIST_VALUE\s0\fR [ \fI\s-1NTH\s0\fR ] [ \fI\s-1SEPARATOR\s0\fR ]
.Sh "Basic functions for use in dotkits only"
.IX Subsection "Basic functions for use in dotkits only"
dk_alter \fI\s-1VARIABLE\s0\fR \fI\s-1COMPONENT\s0\fR [ \fI\s-1SEPARATOR\s0\fR ]
.PP
dk_setenv \fI\s-1VARIABLE\s0\fR [ \fI\s-1VALUE\s0\fR ]
.PP
dk_setdef \fI\s-1VARIABLE\s0\fR [ \fI\s-1VALUE\s0\fR ]
.Sh "Advanced functions for use in dotkits only"
.IX Subsection "Advanced functions for use in dotkits only"
dk_alias \fI\s-1ALIAS_NAME\s0\fR \fI'\s-1ALIAS_DEFINITION\s0'\fR
.PP
dk_cev \fI\s-1VARIABLE\s0\fR
.PP
dk_op [ \fB\-alqv\fR ] \fIpkg\fR [ ... ]
.PP
dk_rep '\fI\s-1PATTERN\s0\fR' [ '\fI\s-1PATTERN\s0\fR' ... ]
.PP
dk_source \fI\s-1FILE\s0\fR
.PP
dk_test \fI\s-1EXPRESSION\s0\fR
.PP
dk_where \fI\s-1PROGRAM_NAME\s0\fR
.Sh "Special variables for use in dotkits"
.IX Subsection "Special variables for use in dotkits"
setenv _dk_err "\fI\s-1ERROR\s0 \s-1MESSAGE\s0\fR"
.PP
setenv _dk_ok "\fI\s-1CUSTOM\s0 \s-1REPLY\s0\fR"
.PP
setenv _dk_hide 0|1
.PP
setenv _dk_pream "\fI\s-1PREFIX\s0\fR"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the reference document for Dotkit commands,
functions, and special variables.
It covers arguments, options, return values, and other usage
details, with brief examples where appropriate.
.PP
An introduction to the \fIuse\fR and \fIunuse\fR commands is available
in the \fIuse\fR\|(1) man page.
The overall structure and organization of Dotkit is
covered in the \fIdotkit\fR\|(1) man page.
Examples of how to write a dotkit,
and how to use the various functions together are provided in the
\&\fIdk\-examples\fR\|(1) man page.
.IP "use [ \fB\-alqv\fR ] [ \fIpkg\fR ... ]" 6
.IX Item "use [ -alqv ] [ pkg ... ]"
.PD 0
.IP "unuse [ \fB\-alqv\fR ] [ \fIpkg\fR ... ]" 6
.IX Item "unuse [ -alqv ] [ pkg ... ]"
.PD
Read the dotkits named as arguments,
and interpret their contents in the current shell process.
If no arguments are given,
run the program \f(CW$DK_ROOT\fR/etc/use\-usage,
which normally provides a view of the current state of your
environment,
and a list of available packages.
.Sp
The \fB\-a\fR \*(L"append\*(R" option causes any components added to environment
variables by \fIpkg\fR to be appended instead of prepended.
If \fB\-a\fR is given with no package arguments,
it causes \fIuse-usage\fR to list all packages,
including any whose name begins with \*(L".\*(R" (dot).
.Sp
The \fB\-l\fR \*(L"long listing\*(R" option
turns off the interpretation (sourcing) of any \fIpkg\fR arguments that follow.
With no other arguments,
this option produces a summary of available dotkits.
If a \fIpkg\fR argument follows,
the descriptive text and any help text for that \fIpkg\fR is
printed to the screen.
The \fB\-l\fR option can be combined with \fB\-v\fR to produce more verbose output.
With no arguments, \fB\-lv\fR prints a usage message,
a list of packages currently in use,
a summary of available packages,
and a list of all nodes in the Dotkit search path.
With a \fIpkg\fR argument, \fB\-lv\fR prints the entire contents of the \fIpkg\fR.
The \fB\-l\fR option is quietly ignored by \fIunuse\fR.
.Sp
The \fB\-q\fR \*(L"quiet\*(R" option causes \fIuse\fR or \fIunuse\fR to be
entirely quiet in operation.
It is commonly used inside dotfiles,
or inside nested (recursive) dotkits.
A special dotkit, \fIbequiet\fR, is available to make the \fB\-q\fR option
persistent.
.Sp
Output behavior similar to \fB\-q\fR,
but allowing notice of particular errors,
can be achieved by setting the \fIdk_taciturn\fR environment variable
to a non-zero value.
A special \fItaciturn\fR dotkit is available to make this mode persistent.
Precise control over the warnings printed in
taciturn mode is achieved by setting the \fIdk_smask\fR
environment variable,
which has a default value of 4094.
\&\fIDk_smask\fR is a bitmask applied to the return status
of \fIuse\fR or \fIunuse\fR, detailed below.
Each bit set in \fIdk_smask\fR allows a warning for that
particular error status, if in taciturn mode.
.Sp
The \fB\-v\fR \*(L"verbose\*(R" option causes \fIuse\fR or \fIunuse\fR to print the full
pathname of each \fIpkg\fR argument as it is found and sourced.
This option over-rides \fB\-q\fR and taciturn mode.
Note that Dotkit also checks whether stdin appears to be a tty.
If not, output messages are turned off for any option except \fB\-v\fR.
.Sp
\&\fIUnuse\fR normally reverses the action of \fIuse\fR.
It finds and reads the \fIpkg\fR argument files,
but causes their actions to be undone relative to \fIuse\fR.
.Sp
Return status:
0 if a dotkit is found and read without
apparent error.
1 means the dotkit was found,
but ignored (previously read),
and 2 means that \fI_dk_err\fR was set during package execution,
indicating a package error.
4 indicates a dotkit was not found at the initial (zeroth) recursion level.
8 indicates a dotkit was not found at the second recursion level,
and so on, up to recursion level nine.
If more than one argument is given,
\&\fIuse\fR and \fIunuse\fR return the status of their last operation.
.IP "reuse [ \fB\-alqv\fR ] [ \fIpkg\fR ... ]" 6
.IX Item "reuse [ -alqv ] [ pkg ... ]"
This command is shorthand for the pair of operations:
.Sp
.Vb 2
\&  unuse pkg
\&  use pkg
.Ve
.Sp
It has the effect of re-reading \fIpkg\fR and moving it to the front of the list
of packages in use.
.IP "alter \fI\s-1VARIABLE\s0\fR \fI\s-1COMPONENT\s0\fR [ \fI\s-1SEPARATOR\s0\fR ]" 6
.IX Item "alter VARIABLE COMPONENT [ SEPARATOR ]"
.PD 0
.IP "unalter \fI\s-1VARIABLE\s0\fR \fI\s-1COMPONENT\s0\fR [ \fI\s-1SEPARATOR\s0\fR ]" 6
.IX Item "unalter VARIABLE COMPONENT [ SEPARATOR ]"
.PD
Add (alter) or remove (unalter) one component
to or from the named \fI\s-1VARIABLE\s0\fR,
a list of zero or more components delimited by \fI\s-1SEPARATOR\s0\fR,
which defaults to the value of \fI\s-1DK_IFS\s0\fR,
or colon if that is not set.
These commands provide interactive or shell script access to the
machinery of the \fIdk_alter\fR function.
Inside a dotkit, you should generally choose \fIdk_alter\fR instead,
as it utilizes its calling context (use or unuse) to add or remove the
\&\fI\s-1COMPONENT\s0\fR, respectively.
.Sp
\&\fIAlter\fR prepends \fI\s-1COMPONENT\s0\fR to \fI\s-1VARIABLE\s0\fR,
unless the \fB\-a\fR (append) option is given.
\&\fIUnalter\fR removes the \fI\s-1COMPONENT\s0\fR, whatever its location.
.IP "car \fI\s-1WORDLIST_VALUE\s0\fR [ \fI\s-1NTH\s0\fR ] [ \fI\s-1SEPARATOR\s0\fR ]" 6
.IX Item "car WORDLIST_VALUE [ NTH ] [ SEPARATOR ]"
.PD 0
.IP "cdr \fI\s-1WORDLIST_VALUE\s0\fR [ \fI\s-1NTH\s0\fR ] [ \fI\s-1SEPARATOR\s0\fR ]" 6
.IX Item "cdr WORDLIST_VALUE [ NTH ] [ SEPARATOR ]"
.PD
\&\fI\s-1WORDLIST_VALUE\s0\fR is a list of components separated by
\&\fI\s-1SEPARATOR\s0\fR, which defaults to the value of \fI\s-1DK_IFS\s0\fR,
or colon if that is not set.
(The value of \f(CW$PATH\fR is one example.)
\&\fICar\fR returns (echoes) the \fI\s-1NTH\s0\fR component of the list,
where \fI\s-1NTH\s0\fR defaults to 0, the index of the first component.
\&\fICdr\fR echoes all components remaining after the \fI\s-1NTH\s0\fR,
with \fI\s-1NTH\s0\fR defaulting to 1 in this case.  Some examples:
.Sp
.Vb 3
\&  car a:b:c 0 :         # => a, equivalent to ``car a:b:c''
\&  car a:b:c 1 :         # => b
\&  car a:b:c 3 :         # => (nil), the empty list
.Ve
.Sp
.Vb 3
\&  cdr a:b:c 0 :         # => a:b:c, the entire list
\&  cdr a:b:c 1 :         # => b:c, equivalent to ``cdr a:b:c''
\&  cdr a:b:c 3 :         # => (nil), the empty list
.Ve
.Sp
If \fI\s-1WORDLIST_VALUE\s0\fR contains whitespace,
it should generally be surrounded by quotes.
.IP "dk_alter \fI\s-1VARIABLE\s0\fR \fI\s-1COMPONENT\s0\fR [ \fI\s-1SEPARATOR\s0\fR ]" 6
.IX Item "dk_alter VARIABLE COMPONENT [ SEPARATOR ]"
(The remaining functions and variables should be accessed only
from within a dotkit or package context.
Calling them directly from the command line or from within a
personal script will yield incorrect results.)
.Sp
\&\fIDk_alter\fR adds to, in the case of \fIuse\fR, or deletes from,
in the case of \fIunuse\fR,
the given component for the given \fI\s-1VARIABLE\s0\fR.
\&\fI\s-1VARIABLE\s0\fR is a list of zero or more
components, separated by \fI\s-1SEPARATOR\s0\fR,
such as the \fI\s-1PATH\s0\fR environment variable.
The default \fI\s-1SEPARATOR\s0\fR is the value of \fI\s-1DK_IFS\s0\fR,
or colon (:) if that is not set.
In particular, \fI\s-1SEPARATOR\s0\fR can be a single \s-1SPACE\s0 or \s-1TAB\s0 character,
generally given inside single quotes.
If a (properly quoted) \fI\s-1COMPONENT\s0\fR itself contains \s-1SPACE\s0 characters,
the \fI\s-1SEPARATOR\s0\fR cannot also be \s-1SPACE\s0.
For any given \fI\s-1VARIABLE\s0\fR, \fI\s-1SEPARATOR\s0\fR is a constant value.
The [t]csh implementation of \fIdk_alter\fR may temporarily modify
the contents of \fI\s-1VARIABLE\s0\fR,
converting \s-1SPACE\s0 characters to `^B' (Control\-B).
.IP "dk_setenv \fI\s-1VARIABLE\s0\fR [ \fI\s-1VALUE\s0\fR ]" 6
.IX Item "dk_setenv VARIABLE [ VALUE ]"
In the case of \fIuse\fR,
set \fI\s-1VARIABLE\s0\fR to \fI\s-1VALUE\s0\fR.
In the case of \fIunuse\fR,
unset the given environment variable.
.Sp
To be more precise,
in the case of \fIuse\fR,
\&\fIdk_setenv\fR checks the variable about to be set,
and if it already has a non-null value,
saves the old value before setting the new.
In the case of \fIunuse\fR,
\&\fIdk_setenv\fR re-installs the value for the duration of the package read,
but places a deferred restore or unsetenv command onto a list to
be executed when the package read is complete.
.Sp
Thus, subsequent \fIdk_alter\fR or \fIdk_setenv\fR commands
in the same dotkit
that use the variable in question will operate as expected.
Moreover, if variables in your environment are reset by a given package,
they will normally be restored to their original value
when the package is \fIunused\fR.
.Sp
Otherwise, \fIdk_alter\fR and \fIdk_setenv\fR take immediate effect,
so the following sequence in a package file has the
manifest outcome:
.Sp
.Vb 3
\&  dk_setenv ABC_HOME /usr/abc
\&  dk_alter PATH $ABC_HOME/bin
\&  dk_alter MANPATH $ABC_HOME/man
.Ve
.Sp
E.g., if \s-1ABC_HOME\s0 has a pre-existing value,
it is first saved by \fIdk_setenv\fR,
then \s-1ABC_HOME\s0 is set to the value \fI/usr/abc\fR.
A new component is added to \s-1PATH\s0 with value \fI/usr/abc/bin\fR,
and a new component to \s-1MANPATH\s0 with value \fI/usr/abc/man\fR.
Unusing the package will remove those components from \s-1PATH\s0 and
\&\s-1MANPATH\s0, and will restore \s-1ABC_HOME\s0 to the value (if any) it had before
the package was \fIused\fR in the first place.
.Sp
Return status: 1 if the second argument is null, otherwise 0.
.IP "dk_setdef \fI\s-1VARIABLE\s0\fR [ \fI\s-1VALUE\s0\fR ]" 6
.IX Item "dk_setdef VARIABLE [ VALUE ]"
This is a variant of \fIdk_setenv\fR that sets \fI\s-1VARIABLE\s0\fR to
\&\fI\s-1VALUE\s0\fR only if \fI\s-1VARIABLE\s0\fR is currently unset or has the
\&\s-1NULL\s0 (empty string) value.
It is otherwise the same as \fIdk_setenv\fR.
.Sp
For the \fIunuse\fR operation,
\&\fIdk_setdef\fR unsets \fI\s-1VARIABLE\s0\fR only if the prior \fIuse\fR
set it to the the given default \fI\s-1VALUE\s0\fR, 
(or if the variable's previous value was identically \fI\s-1VALUE\s0\fR.)
.IP "dk_alias \fI\s-1ALIAS_NAME\s0\fR \fI'\s-1ALIAS_DEFINITION\s0'\fR" 6
.IX Item "dk_alias ALIAS_NAME 'ALIAS_DEFINITION'"
Create (or remove, in the case of \fIunuse\fR),
the alias \fI\s-1ALIAS_NAME\s0\fR with the given definition.
The syntax of \fIdk_alias\fR is essentially identical to that of the
csh or tcsh \fIalias\fR command,
except that alias arguments are not allowed.
(To be precise, arguments *can* be given,
but such syntax cannot, at present,
be part of a shell-independent dotkit.)
.Sp
Dotkits containing the \fIdk_alias\fR command normally should
be marked as \fIidempotent\fR by appending '++' to the
dotkit name (e.g., \fIfoo++.dk\fR.)
This allows Dotkit to read the package more than once,
a requirement if subshells are to receive proper alias definitions.
.IP "dk_cev \fI\s-1VARIABLE\s0\fR" 6
.IX Item "dk_cev VARIABLE"
Print the value 1 if you can safely evaluate \fI\s-1VARIABLE\s0\fR,
or 0 otherwise.
.Sp
Typical usage:
.Sp
.Vb 1
\&  dk_test `dk_cev FOO` -eq 1 && dk_setenv BAR $FOO
.Ve
.Sp
This provides shell-independent code equivalent to the csh test:
.Sp
.Vb 3
\&  if ($?FOO) then
\&    dk_setenv BAR $FOO
\&  endif
.Ve
.Sp
\&\fIDk_cev\fR always prints 1 for bash or ksh,
as those shells traditionally do not distinguish
between unset variables and variables that are set,
but whose value is the empty string.
.Sp
Return status for this function is always 0.
The relevant value is the one that it *prints*.
.IP "dk_op [ \fB\-alqv\fR ] \fIpkg\fR [ ... ]" 6
.IX Item "dk_op [ -alqv ] pkg [ ... ]"
\&\fIUse\fR or \fIunuse\fR the \fIpkg\fR, depending on the context in which
\&\fIdk_op\fR occurs.
This command is used inside recursive or nested dotkits,
to read and source sub\-packages.
If the parent dotkit was \fIused\fR,
then \fIdk_op\fR also means \fIuse\fR.
If the parent dotkit was \fIunused\fR,
then \fIdk_op\fR unuses its argument list.
Options, usage, and return values are otherwise
identical to \fIuse\fR and \fIunuse\fR.
However, the \fB\-l\fR option should never be used with this command.
.IP "dk_rep '\fI\s-1PATTERN\s0\fR' [ '\fI\s-1PATTERN\s0\fR' ... ]" 6
.IX Item "dk_rep 'PATTERN' [ 'PATTERN' ... ]"
Print the names, if any, of dotkits presently in use whose
name matches \fI\s-1PATTERN\s0\fR,
in the sense of shell pattern matching.
If no names match, the token \*(L"_\|_NIL_\|_\*(R" is printed.
One or more patterns can be given,
and can include the usual shell meta\-characters.
Single quotes around the pattern are generally required.
The \fIdk_rep\fR function is commonly used in the case
of \fImutex\fR (mutually exclusive) dotkits.
.Sp
Return status: 0 if at least one dotkit currently in use matches the
given pattern(s), otherwise 1.
.IP "dk_source \fI\s-1FILE\s0\fR" 6
.IX Item "dk_source FILE"
This command is equivalent to \*(L"source\*(R" for csh or tcsh,
or \*(L".\*(R" for bash and ksh,
with the same return values as those commands.
It allows you to read the contents of another file in your
current shell, from within a package file.
This is occasionally useful.
If \fI\s-1FILE\s0\fR is itself a dotkit, use \fIdk_op\fR instead.
.IP "dk_test \fI\s-1EXPRESSION\s0\fR" 6
.IX Item "dk_test EXPRESSION"
Apply the standard Unix \fItest\fR\|(1) command to \fI\s-1EXPRESSION\s0\fR.
\&\fIDk_test\fR takes the same expressions as that program,
with the same return values,
and can be used to construct simple if-else tests
in your dotkits, in shell-independent fashion:
.Sp
.Vb 1
\&  dk_test -d /usr/local/gribble && dk_setenv GRIBBLE YES
.Ve
.Sp
sets \s-1GRIBBLE\s0 to \s-1YES\s0 if /usr/local/gribble is a directory.
See the \fItest\fR\|(1) man page for more information on that command.
.IP "dk_where \fI\s-1PROGRAM_NAME\s0\fR" 6
.IX Item "dk_where PROGRAM_NAME"
Print the full path of \fI\s-1PROGRAM_NAME\s0\fR if found,
returning status 0,
or be silent, with return status 1.
\&\fIDk_where\fR searches first in the current \fI\s-1PATH\s0\fR,
then searches the in order
/bin, /usr/bin, /sbin, /usr/sbin, /usr/ucb, /usr/bsd, /usr/local/bin
for \fI\s-1PROGRAM_NAME\s0\fR.
\&\fIDk_where\fR is implemented as an external script,
located at \f(CW$DK_ROOT\fR/etc/where.
.IP "Special variables" 6
.IX Item "Special variables"
.Vb 4
\&  setenv _dk_err "<error message>"
\&  setenv _dk_ok "<custom reply>"
\&  setenv _dk_hide 0|1
\&  setenv _dk_pream "PREFIX"
.Ve
.Sp
The \fI_dk_err\fR variable is used to indicate that something
went wrong while reading a package file.
Set it to a string value,
which will be printed in place of the usual \*(L"(ok)\*(R" when Dotkit
returns after reading the package file.
After \fI_dk_err\fR is set in a package file,
subsequent \fIdk_alter\fR, \fIdk_setenv\fR, \fIuse\fR, \fIunuse\fR,
or \fIdk_op\fR commands inside 
that file are ignored,
and the package name is not added to the list of current
packages in use.
.Sp
The \fI_dk_ok\fR variable allows a package author to customize the
reply message from Dotkit after attempting to read a package.
By default, if the package is found and read successfully,
the reply is \*(L" (ok)\*(R".
If \fI_dk_ok\fR is set, its value is substituted for the default text.
Setting \fI_dk_ok\fR does not affect return status.
If \fI_dk_err\fR is also set, its value will dominate \fI_dk_ok\fR.
.Sp
\&\fI_Dk_hide\fR is a boolean variable whose value is normally 0 (\s-1FALSE\s0).
Set it to 1 (\s-1TRUE\s0) if you wish to hide (not include)
the current package in the list of packages in use.
This is occasionally useful in a \*(L"worker\*(R" package
that is called from various places,
but which should not show up itself as in use.
Obviously, such a package needs to be written with re-use in mind,
since hiding it also prevents Dotkit from ignoring it in
any future \*(L"use\*(R" request.
.Sp
The \fI_dk_pream\fR variable allows a package author to over-rule
the \fB\-a\fR flag if necessary, or conversely, to force an append operation
even if the user does not provide \fB\-a\fR.
Typical use is as follows:
.Sp
.Vb 4
\&  # Force prepend "bar" to "foo".
\&  dk_test "$_dk_pream" = "Appending" && \e
\&    setenv _dk_pream "Prepending"
\&  dk_alter foo bar
.Ve
.Sp
Note the leading underscore in the names of these variables,
and note that their value is properly set using \fIsetenv\fR,
not \fIdk_setenv\fR.
They are reset automatically by Dotkit before
the next operation.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.IP "\s-1DK_ROOT\s0" 6
.IX Item "DK_ROOT"
Path to the root of a Dotkit installation.
The code implementing Dotkit is stored in the various \fI*sh\fR
subdirectories of \f(CW$DK_ROOT\fR, and at \f(CW$DK_ROOT\fR/etc.
\&\s-1DK_ROOT\s0 is also the root node on the tree of directories
searched for package files.
.IP "\s-1DK_NODE\s0" 6
.IX Item "DK_NODE"
Optional colon-separated list of directories added to
the path searched by Dotkit.
This is often used to add site-specific dotkits to an installation.
.IP "\s-1SYS_TYPE\s0" 6
.IX Item "SYS_TYPE"
A string identifying the current architecture.
\&\s-1SYS_TYPE\s0 may be pre-set for you by the network administrators.
If not,
a script is provided at \f(CW$DK_ROOT\fR/etc/systype to compute some
common values of \s-1SYS_TYPE\s0.
.IP "\s-1DK_USEUSAGE\s0" 6
.IX Item "DK_USEUSAGE"
Optional pathname to a replacement for the \f(CW$DK_ROOT\fR/etc/use\-usage program.
.IP "_dk_shell" 6
.IX Item "_dk_shell"
The base name of your shell interpreter program:
\&\fIbash\fR, \fIcsh\fR, \fIksh\fR, or \fItcsh\fR. 
.IP "\s-1DK_SUBNODE\s0" 6
.IX Item "DK_SUBNODE"
A colon-separated list of directories searched for package
files within each node of the package file tree.
The default value for \s-1DK_SUBNODE\s0 has four components:
.Sp
.Vb 1
\&  $_dk_shell/$SYS_TYPE:$_dk_shell:$SYS_TYPE:.
.Ve
.Sp
It can be useful to change or add to this list in certain special
circumstances.
.IP "_dk_inuse" 6
.IX Item "_dk_inuse"
A space-separated list of package names currently in use.
A trailing digit identifies the recursion level at which the
package was loaded,
with 0 being the top (command line) level,
and 9 the deepest (maximum) level.
.IP "_dk_rl" 6
.IX Item "_dk_rl"
The \*(L"recursion level\*(R" for Dotkit:
An integer variable with legal values in the range \-1, 0, 1, ..., 9.
When not actually processing a \*(L"use\*(R" or \*(L"unuse\*(R" command,
the correct value for _dk_rl is \-1.
.IP "\s-1DK_EXPORT_BASH_FNS\s0" 6
.IX Item "DK_EXPORT_BASH_FNS"
Dotkit is implemented primarily using shell functions for bash and ksh.
By default, those functions are not exported to the environment for
bash users.  Bash users can choose to export the Dotkit shell functions
by defining this environment variable to '\s-1YES\s0' (or any other non-null
string) before executing the \*(L"eval `.../dotkit/init`\*(R" initialization
command.
.IP "\s-1DK_IFS\s0" 6
.IX Item "DK_IFS"
Defines the character used to separate components
of wordlist variables.
If unset, the default is ':' (colon).
.IP "\s-1DK_UEQRU\s0" 6
.IX Item "DK_UEQRU"
If this variable is set to a non-null value,
the \*(L"use\*(R" command behaves as a \*(L"reuse\*(R".
That is, any package arguments are first (quietly) unused,
then re\-read.
This can occasionally be helpful if processes other than Dotkit
are changing the environment.
A \fIreuse\fR dotkit is available to conveniently set or unset this
variable.
.SH "BUGS"
.IX Header "BUGS"
It would be nice if the \fIdk_alias\fR command would save and
restore alias definitions,
like \fIdk_setenv\fR does for environment variables.
It would be nice if \fIdk_alias\fR accepted arguments for all shells,
and wrote an appropriate shell function in the case of bash or ksh.
.PP
Handling of null (empty) components in \fIdk_alter\fR, \fIalter\fR, \fIunalter\fR
is inconsistent and sometimes incorrect.
Adding a null component to an empty wordlist produces a double null;
removing one null component then removes them both.
Once added, a null component is difficult to remove for the [t]csh version.
Null components in a context where the \s-1SEPARATOR\s0 character is whitespace
will often produce incorrect results.
.SH "AUTHOR"
.IX Header "AUTHOR"
The original author of Dotkit is
Lee Busby, Lawrence Livermore National Laboratory.
Adam Moody, also of \s-1LLNL\s0,
has made additional major contributions.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004, The Regents of the University of California.
See the file named \*(L"Copyright\*(R" for the full text of the copyright notice.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
dk-commands(5), dk-examples(5), dotkit(7), use(1), dk-admin(8).
